#include <stdio.h>

int main()
{
	int arr[5] = { 1, 3, 5, 7, 9 };
	int (*a)[5] = &arr;

	for (int i = 0; i < 5; i++)
	{
		printf("arr[%d]의 값: %d\n(*a)[%d]의 값: %d\n\n", i, *(arr + i), i, *((*a) + i)); // arr 과 (*a) 는 각각 배열명이 된다. 따라서 + 연산을 해주면 더해준 값 만큼 메모리 공간을 이동한다.
	}

	int arr2[3][5] = { {10, 20, 30, 40, 50}, {100, 200, 300, 400, 500}, {1000, 2000, 3000, 4000, 5000} };
	a = arr2; // 배열명은 포인터상수이므로 lvalue 로 간주되어 값 변경이 불가하다. 하지만 (*a) 의 값은 변경할 수 없어도 a는 주소의 형태이기 때문에 다른 주소를 가리킬 수 있다. arr2 자체도 주소의 형태

	printf("arr의 크기: %d\narr2의 크기: %d\na의 크기: %d\n(*a)의 크기: %d\n\n", sizeof(arr), sizeof(arr2), sizeof(a), sizeof(*a)); // a 는 포인터상수이자 배열포인터이다. 따라서 4byte 의 크기를 가진다. 하지만 *a 는 arr2 의 아래 차원 인덱스들의 크기들의 합이 된다.
	// 현재 arr2 는 2차원 배열이고, 1차원 인덱스들은 5개가 있고 int 형 이므로 1차원 전체의 크기는 20, 따라서 *a 의 크기도 20 이 된다.

	//배열포인터가 가리키는 값. 배열명 (*a) 는 arr2 의 첫번째 주소부터 가진다. 따라서 첫번째 인덱스부터 출력하게 된다.
	for (int i = 0; i < 15; i++)
	{
		printf("(*a) + %d 의 값: %d\n", i, *((*a) + i));
	}//배열포인터를 이용하면 이중 for문을 할 필요없이 한번에 모든 값들을 출력할 수 있다.

	puts("");

	//배열포인터를 이용, 포인터 연산으로 2차원 배열 출력
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			printf("arr2[%d][%d]의 값: %d\n", i, j, *((*(arr2 + i)) + j)); // i 는 2차원, j 는 1차원에서 움직인다. 배열포인터의 +연산은 곧 고차원에서의 인덱스 이동을 의미하기 때문.
		}
	}

	puts("");

	//배열포인터를 이용, 인덱스를 이동하며 2차원 배열 출력
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 5; j++)
		{
			printf("(*(a + %d))[%d]의 값: %d\n", i, j, (*(a + i))[j]); // a + i 는 배열의 2차원 메모리에서 한 칸 움직인다. 즉, 2차원에 할당된 인덱스의 수와 int 타입의 크기를 곱한 만큼 메모리가 이동한다.
		} // arr2[0][0] 부터 arr2[2][4] 까지 차례로 출력된다.
	}

	return 0;
}